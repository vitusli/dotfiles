# ============================================================================
# PowerShell Profile (Windows)
# ============================================================================

# Enable tab completion for Winget
try {
    Register-ArgumentCompleter -Native -CommandName winget -ScriptBlock {
        param($wordToComplete, $commandAst, $compPoint)
        winget complete --word $wordToComplete --commandline $commandAst.ToString() --position $compPoint |
            ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_) }
    }
} catch {
    Write-Verbose "Winget completion registration failed: $($_.Exception.Message)"
}

# Enable tab completion for chezmoi
try {
    chezmoi completion powershell | Out-String | Invoke-Expression
} catch {
    Write-Verbose "Chezmoi completion registration failed: $($_.Exception.Message)"
}

# Add scoop to PATH
$machinePath = [Environment]::GetEnvironmentVariable("Path", "Machine")
$userPath = [Environment]::GetEnvironmentVariable("Path", "User")
$env:Path = "$machinePath;$userPath"
$env:Path = "{{ .chezmoi.homeDir }}\scoop\apps\mingw\current\bin;{{ .chezmoi.homeDir }}\scoop\shims;$env:Path"

# Add NovaCLI to PATH
$env:Path = "{{ .chezmoi.homeDir }}\NovaCLI;$env:Path"

# fzf: Copy result to clipboard on Enter (in addition to normal output)
$env:FZF_DEFAULT_OPTS = "--bind 'enter:execute-silent(powershell -nop -c Set-Clipboard {})+accept'"

# Default editor (like VISUAL/EDITOR in zsh)
$env:EDITOR = "nvim"
$env:VISUAL = "code"


# ============================================================================
# Module Management
# ============================================================================
# Automatically install and import required modules
$requiredModules = @('PSReadLine', 'PSFzf')
foreach ($module in $requiredModules) {
    if (-not (Get-Module -ListAvailable -Name $module)) {
        Write-Host "Installing $module..."
        Install-Module $module -Scope CurrentUser -Force
    }
    Import-Module $module
}

# PSFzf configuration (Ctrl+T for file search, Ctrl+R for history)
Set-PsFzfOption -PSReadlineChordProvider 'Ctrl+t' -PSReadlineChordReverseHistory 'Ctrl+r'

# Initialize zoxide (smart cd replacement)
Invoke-Expression (& { (zoxide init powershell | Out-String) })

# ============================================================================
# Vi Mode
# ============================================================================
# Define ViModeChange handler FIRST
$OnViModeChange = [scriptblock]{
   if ($args[0] -eq 'Command') {
       # Set the cursor to a blinking block.
       Write-Host -NoNewLine "`e[2 q"
   }
   else {
       # Set the cursor to a line.
       Write-Host -NoNewLine "`e[6 q"
   }
}

# THEN enable Vim with the handler
Set-PsReadLineOption -EditMode Vi
Set-PSReadLineOption -ViModeIndicator Script -ViModeChangeHandler $OnViModeChange

# MenuComplete AFTER Vi mode (Vi mode overrides Tab binding)
Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete

# Set the initial cursor to a line for Insert Mode
Write-Host -NoNewLine "`e[6 q"

# Reset cursor to line after every command (like zsh zle-line-init)
$PSDefaultParameterValues['Out-Default:OutVariable'] = '__lastOutput'
Set-PSReadLineOption -ExtraPromptLineCount 0
$function:prompt = {
    # Reset cursor to line for Insert Mode after every command
    Write-Host -NoNewLine "`e[6 q"
    "PS $($executionContext.SessionState.Path.CurrentLocation)$('>' * ($nestedPromptLevel + 1)) "
}

# ============================================================================
# Abbreviations (generated from .chezmoidata.yaml)
# ============================================================================
$Abbreviations = [System.Collections.Hashtable]::new([System.StringComparer]::Ordinal)
{{- range $abbr, $cmd := .abbreviations.universal }}
$Abbreviations['{{ $abbr }}'] = '{{ $cmd }}'
{{- end }}
{{- range $abbr, $cmd := .abbreviations.windows }}
$Abbreviations['{{ $abbr }}'] = '{{ $cmd }}'
{{- end }}

Set-PSReadLineKeyHandler -Key ' ' -ScriptBlock {
    $line = $null
    $cursor = $null
    [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$line, [ref]$cursor)

    $tokens = $line -split '\s+'
    $firstToken = $tokens[0]

    if ($Abbreviations.ContainsKey($firstToken)) {
        [Microsoft.PowerShell.PSConsoleReadLine]::Replace(0, $firstToken.Length, $Abbreviations[$firstToken])
    }
    [Microsoft.PowerShell.PSConsoleReadLine]::Insert(' ')
}

Set-PSReadLineKeyHandler -Key 'Enter' -ScriptBlock {
    $line = $null
    $cursor = $null
    [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$line, [ref]$cursor)

    $tokens = $line -split '\s+'
    $firstToken = $tokens[0]

    if ($Abbreviations.ContainsKey($firstToken)) {
        [Microsoft.PowerShell.PSConsoleReadLine]::Replace(0, $firstToken.Length, $Abbreviations[$firstToken])
    }
    [Microsoft.PowerShell.PSConsoleReadLine]::AcceptLine()
}

# ============================================================================
# Completions
# ============================================================================
# Scoop completion (installed via scoop, per Moeologist README)
try {
    if (Get-Command scoop -ErrorAction SilentlyContinue) {
        $scoopRoot = (Get-Item (Get-Command scoop.ps1).Path).Directory.Parent.FullName
        $modulePath = Join-Path $scoopRoot 'modules\scoop-completion'
        if (Test-Path $modulePath) {
            Import-Module $modulePath -ErrorAction Stop
        } else {
            Write-Verbose "scoop-completion module path not found: $modulePath"
        }
    }
} catch {
    Write-Verbose "Scoop completion load failed: $($_.Exception.Message)"
}

# gsudo module (enables `gsudo !!` to elevate last command)
Import-Module gsudoModule -ErrorAction SilentlyContinue

# ============================================================================
# / - Fuzzy find files/directories and open in VS Code
# ============================================================================
function / {
    # Search directories
    $searchDirs = @(
        "$HOME\Downloads",
        "$HOME\Documents",
        "$HOME\Desktop",
        "$HOME\.local\share\chezmoi",
        "$HOME\codespace"
    )
    $homeDepth = 3

    # Use fd for fast file finding, fallback to Get-ChildItem if fd not available
    if (Get-Command fd -ErrorAction SilentlyContinue) {
        $target = & {
            foreach ($dir in $searchDirs) {
                if (Test-Path $dir) {
                    fd . $dir --type f --type d 2>$null
                }
            }
            fd . $HOME --max-depth $homeDepth --type f --type d 2>$null
        } | fzf --prompt=": " --preview="if (Test-Path -PathType Leaf '{}') { bat --color=always --style=numbers '{}' } else { Get-ChildItem '{}' }" --preview-window="right:60%:wrap"
    } else {
        $target = & {
            foreach ($dir in $searchDirs) {
                if (Test-Path $dir) {
                    Get-ChildItem -Path $dir -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $_.FullName }
                }
            }
            Get-ChildItem -Path $HOME -Depth $homeDepth -ErrorAction SilentlyContinue | ForEach-Object { $_.FullName }
        } | fzf --prompt=": "
    }

    if ([string]::IsNullOrEmpty($target)) {
        return
    }

    Set-Clipboard -Value $target
    & $env:VISUAL $target
    Write-Host "Opened in $($env:VISUAL): $target"
}
